---
title: "Processing family tracks 01"
---
  
```{r load_env, message=FALSE, warning=FALSE}
source("knitr_options.r")
library(zoo);library(plyr);library(dplyr);library(purrr)
#'suppress all code output but run code
opts_chunk$set(eval = FALSE)
opts_knit$set(root.dir = "~/git/thesis/code")
```

```{r load_famtracks}
load("fams2016.nobursts.rdata")
load("~/git/thesis/code/fams2014.rdata")
load("fams2015.rdata")
```


```{r join_lists}
#'modify lists to have the adult in position
#'fam An
fams2014[["An"]] = rev(fams2014[["An"]])
#'fam Ro
fams2014[["Ro"]] = fams2014[["Ro"]][c(2,3,1,4)]

#'family Ha
fams2015[["Ha"]] = fams2015[["Ha"]][c(3,1,2,4,5)]

#'family Jo
fams2015[["Jo"]] = rev(fams2015[["Jo"]])

#'family Na
fams2015[["Na"]] = rev(fams2015[["Na"]])

#'family Ad
fams2016.4[["Ad"]] = fams2016.4[["Ad"]][c(3,2,1,4,5)]

#'family Ti
fams2016.4[["Ti"]] = fams2016.4[["Ti"]][c(3,2,1,4)]

#'family Ev
fams2016.4[["Ev"]] = fams2016.4[["Ev"]][c(5,4,1,2,3,6)]

#'family Wo
fams2016.4[["Wo"]] = fams2016.4[["Wo"]][c(4,3,1,2,5)]
```

```{r}
#'remove dates outside the single year
fams2014 = lapply(fams2014, function(x){lapply(x, function(y){y %>% filter(t < "2014-04-01")})})

fams2015 = lapply(fams2015, function(x){lapply(x, function(y){y %>% filter(t < "2015-04-01")})})
```


```{r append_lists}
f1 = append(fams2014, c(fams2015, fams2016.4))
```


```{r round_time}
library(plyr);library(dplyr)
f1 = lapply(f1, function(x){lapply(x, function(y){y %>% mutate(t = round_date(t, "30 minute"))})})
#'round time to the nearest minute
f1 = lapply(f1, function(x){lapply(x, function(y){y %>% mutate(t = round_date(t, "30 minute"))})})


#'remove v, fam, and lag
f1 = lapply(f1, function(x){lapply(x, function(y){y %>% select(t, lon, lat)})})

#'round position to the half hour
f1 = lapply(f1, function(x){lapply(x, function(y){y %>% slice_rows("t") %>% dmap(function(x) mean(x, na.rm = T))})})
```

```{r distances}
library(purrr)
#'a left join here
f2 = lapply(f1, function(x){reduce(x, left_join, by = "t")})
```

```{r get_distances}
library(geosphere)

#'get distances in another list

fdists = vector("list", 13)

for(z in 1:length(f2)){
 for(i in 1:dim(f2[[z]])[1]){
  for(j in seq(1, length(f2[[z]])-2 ,2))
   fdists[[z]] = c(fdists[[z]], distVincentyEllipsoid(p1 = f2[[z]][i,c(2,3)], p2 = f2[[z]][i,c(j+1,j+2)]))
}
}
```

```{r dist_matrix}
#'make a duplicate
fdistm = fdists

#'make each numeric column a matrix. this will need a for loop
for(i in 1:length(f2)){
  fdistm[[i]] = matrix(fdistm[[i]], ncol = length(f1[[i]]), byrow = T)
}
```

```{r convert_to_df}
#'make dists a df
fdistm = lapply(fdistm, function(x){x = as.data.frame(x)})

#'add names to dfs
names(fdistm) = names(f2)
```

```{r}
save(fdistm, f2, file = "famdists02.rdata")
```

# Dead or alive?

If more than 20 points are consecutively missing, ie, after 10 hours, set the remaining points to Inf.

```{r}
#'set all NA to Inf. turns the dfs into a list again.
fdistm2 = lapply(fdistm, function(x){lapply(x, function(y){replace(y, which(is.na(y)), NA)})})
```

```{r check_na}
fdistm2 = lapply(fdistm2, function(x){lapply(x, function(y){
  cbind(as.data.frame(y), c = rollapply(is.na(y), c(rep(100, length(y)-100), seq(100,1)), sum, align = "left"))
})})
```

```{r assign_missing}
#'here, if the y value is NA, and the c value for that row is > 100, assign that value and all following to Inf. if the value is NA, and the c value is < 100, assign -Inf.

fdistm3 = lapply(fdistm2, function(x){lapply(x, function(y){
  y = ifelse(is.na(y$y) & y$c >=100, Inf,
         ifelse(is.na(y$y), -Inf, y$y))
})})
```

```{r family_or_not}
#'if a distance value is Inf, the next 100 values are NA. this is a function of the logger, not the goose, but values of Inf are indistinguishable from values above 250m. 
#'to check if the family is migrating together, if the last distance to each goose is less than 1000m (very generous), set all Inf to -Inf, which indicates logger error, rather than juvenile dispersal.

fdistm3 = lapply(fdistm3, function(x){lapply(x, function(y){
  y = ifelse(last(y) <= 1000 & y == Inf, -Inf, y)
})})
```

```{r make_df_sizes}
#'make df
fdistm3 = lapply(fdistm3, as.data.frame)

#'get family sizes per half hour
fdistm3 = lapply(fdistm3, function(x){x %>% mutate(fsize= apply(x, 1, function(y){sum(y<1250)}))})
```



```{r add_time}
#'add the timestamps to the matrix
for(i in 1:length(f2)){
  fdistm3[[i]] = cbind(fdistm3[[i]], time = (f2[[i]]$t))
}

library(lubridate)

#'round time to the day
fsize = lapply(fdistm3, function(x){x = x %>% plyr::summarise(time = round_date(time, "day"), fsize)})
```

```{r get_maxsize}
library(purrr)
#'get max family size per day
fsize2 = lapply(fsize, function(x){x = x %>% slice_rows("time") %>% dmap(max)})

#'set famsize to the max famsize in the next 10 days
fsize2 = lapply(fsize2, function(x){x = x %>% mutate(fsize = rollapply(fsize, c(rep(30, dim(x)[1]-30), seq(30,1)), max, align = "left"))})
```

```{r}
save(fsize2, file = "fsize.rdata")
```

# Attach coordinates

```{r get_coords}
#'get coords
daycoords = lapply(f2, function(x){x %>% select(t, lon.x, lat.x) %>% plyr::summarise(time = round_date(t, "day"), lon = lon.x, lat = lat.x)})

#'merge coords with fsize2 and assign families
for(i in 1:length(daycoords)){
  daycoords[[i]] = merge(daycoords[[i]], fsize2[[i]], by = "time")
  daycoords[[i]]$fam = names(fsize2)[i]
}

#'rbind the list
daycoords = bind_rows(daycoords)

save(daycoords, file = "fsize_coords.rdata")
write.csv(daycoords, file = "trackedfamilysizes.csv")
```

```{r}
library(ggplot2)

pdf()
daycoords %>% filter(fam %in% c("Ev","Ha","Ti","Wo")) %>%
ggplot()+
  geom_path(aes(x=time, y=fsize, col = lon), size = 4)+
  scale_color_gradientn(colours = rev(gray.colors(6)))+
  facet_wrap(~fam, scales = "free")+
  labs(list(x = "Time",y = "Family size (incl. ads.)"))+
  theme_minimal()
```

# Juvenile distances over winter

```{r}
#'load data
load("famdists02.rdata")

#'get the mean distances excluding the first two columns
fdmean = lapply(fdistm, function(x){select(x,-c(V1,V2)) %>% apply(1, function(y){mean(y, na.rm = T)})})

#'add timestamps
for(i in 1:length(fdmean)){
  fdmean[[i]] = data.frame(meandist = fdmean[[i]])
  fdmean[[i]]$time = f2[[i]]$t
}
```

